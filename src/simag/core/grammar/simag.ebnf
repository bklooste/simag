(* Grammar for the SIMAG declarative language / GRAKO definitions (outdated) *)

@@comments			::	?/\*((?:.|\n)*?)\*|#(.*?)\n/?
@@eol_comments 		::	/#.*?$/

block	 = {stmt}+ $ ;
stmt	= assertion:multi_assert
			| stmt:(comp_type | icond_type)
			|	rule:(icond_expr | comp_expr)
			|	query:query ;

icond_type			=	'(' {(vars:var_decl | skol:skol_decl)} expr:icond_root ')' ;
icond_root			= 	'(' lhs:expr_node op:icond_op rhs:icond_node ')' ;
icond_expr			=	'(' lhs:expr_node op:(icond_op | or_op) rhs:icond_node ')' ;
icond_node			=	(terminal_node | icond_expr) ;

comp_type			=	'(' {skol:skol_decl} (assertion:multi_assert | expr:comp_expr) ')' ;
comp_expr			=	'(' lhs:expr_node op:logic_op rhs:expr_node ')' ;
expr_node			=	(terminal_node | comp_expr) ;
query				=	'(' {(vars:var_decl | skol:skol_decl)}+ query:terminal_node ')' ;

var_decl = '(' 'let' @+:(term [':' op_arg]) {',' @+:(term [':' op_arg])} ')' ;
skol_decl	=	'(' 'exists' @+:(term [':' op_arg]) {',' @+:(term [':' op_arg])} ')' ;
terminal_node	=	(klass:class_decl | func:func_decl | assertion:multi_assert) ;
multi_assert		= 	'(' (@+:class_decl | @+:func_decl)
							{and_op (@+:class_decl | @+:func_decl)} ')'
					|	'(' 'decl' (@+:class_decl | @+:func_decl)
							{';' (@+:class_decl | @+:func_decl)} ')';

class_decl = klass:term ['(' op_args:op_args ')'] args:args ;
func_decl  = 'fn::' func:term ['(' op_args:op_args ')'] args:args
					 | 'fn::' func:term '(' op_args:op_args ')' ;
args				=	'[' @+:arg {';' @+:arg} ']';
arg					=	term:term [',' uval:uval] ;
uval                =   'u' @+:comp_op @+:number ;
op_args				=	@+:op_arg {',' @+:op_arg} ;
op_arg				=	first_term:(string|term) [op:comp_op second_term:(string|term)] ;

icond_op			=	'|>' ;
and_op				=	'&&' ;
or_op				=	'||' ;
logic_op	        =   '<=>'
		            |   '=>'
               		|   or_op
               		|	and_op ;
comp_op				=	('=' | '<' | '>') ;
term				=	?/\$?[a-zA-Z0-9_]+/? ;
number       =   ?/-?[0-9\.]+/? ;
string			=	?/".*?"|'.*?'/? ;
